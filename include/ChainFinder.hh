//Modify by Jixie: 
//Change this code to a class
//The whole class is in unit of cm and rad

#ifndef _ChainFinder_H_
#define _ChainFinder_H_ 1

#define MAX_HITS_PER_EVENT  5000   
#define MAX_CHAINS_PER_EVENT 100        
#define MAX_HITS_PER_CHAIN   200       
#define Min_HITS_PER_CHAIN   5   


/* The status bits for hits in the hitlists */
#define HUNTCHD 0  /* - untouched - no status set yet */
#define HISUSED 1  /* - (was 1) used */
#define HREMOVD 2  /* - (was 2)removed for high residual to helix */
#define HDISEAR 4  /* - t<TPC_TMIN */
#define HDISLAT 8  /* - t>TPC_TMAX */
#define HEARLST 0x10  /* - this hit is has earliest time for this pad on this chain */
#define HABSORB 0x20  /* - hit absorbed in routine weightData */
#define HSMALLQ 0x40  /* - (was -3) charge < THR_Q_LINK */
#define HITTEMP 0x80  /* for routine-specific status marks. */
#define FAKE_HIT 0x100 /* any type of artificially-generated hit */
#define PROJECTED_HIT 0x200 /* indicates a hit generated by projecting fitted track */
#define SWUMHIT 0x400 /* indicates a hit generated by swimming the track */
#define HBADPAD 0x800 /* hit is on a pad marked as bad */
#define HITUNAV (HISUSED|HDISEAR|HDISLAT|HABSORB|HSMALLQ|FAKE_HIT|HBADPAD) /* reasons to NOT use a hit in the chain-linker */

      
//By Jixie:  I add ChainInfo to tell ChainIndex cc and HitIndex jj
//ChainInfo  = cccjjj,  where ccc is ChainIndex and jj is HitIndex 
//ThrownTID  = cccjjj,  where ccc is TrackIndex and jj is HitIndex 
typedef struct {
  int ID;
  int TDC;
  int ADC;
  double X;
  double Y;
  double Z;
  int Status;
  //the following is added by Jixie in order to do sorting
  double S;       // distance to beam line
  double Phi;     //from -pi to pi
  int ThrownTID;  //To tell which track it was originally from
  int ChainInfo;  //to tell which chain this hit belongs to
}HitStruct;


typedef struct {
  int ID;     //Chain ID
  int HitNum; //Number of hits in this chain
  HitStruct* Hits[MAX_HITS_PER_CHAIN];
}ChainStruct;


class ChainFinder {
public:
  ChainFinder();
  virtual ~ChainFinder();
  
  void Reset();
  //provide x,x,z in mm
  void PrepareHitPool_mm(int *id, int *tdc, int *adc, double *x_mm, double *y_mm, 
                         double *z_mm, int n, int *throwntid=0, int append=0);
  //provide x,x,z in cm
  void PrepareHitPool(int *id, int *tdc, int *adc, double *x, double *y,
                      double *z, int n, int *throwntid=0, int append=0);
  
  int  SearchHitsForASeed(int seed, int seed_pre); 
  void SearchChains(int do_sort=1);  
  void StoreAChain(int chainid);

  //incert a hit into hitpool at position==hitid
  void InsertAHitToPool(int hitid, int id, int tdc, int adc, double x, double y, double z, int ThrownTID=-1, int ChainInfo=-1);
  //return number of hit that removed
  int  RemoveAHitFromPool(int hitid);
  //return number of hit that removed
  int  RemoveBadHitsFromPool();
  //the real data in bonus6 it in channel ID increasing order, for the same ID,
  //TDC in decreasing order
  //sort hitpool to match this order
  void SortHitPoolByIDTDC();

  
  void SetParameters(double space, double min_ang, double max_ang, double ang_sep);

private:  
  
  //add a hit to end of fHitIDInAChain[MAX_CHAINS_PER_EVENT][MAX_HITS_PER_CHAIN];
  //will not touch fChainBuf yet
  //if the chain is full return 0, otherwise 1
  int  AddAHitToChain(int seed, int chainid, int hitid, double separation);

  //incert a hit to given position of fHitIDInAChain[MAX_CHAINS_PER_EVENT][MAX_HITS_PER_CHAIN];
  //will not touch fChainBuf yet
  void InsertAHitToChain(int chainid, int hitid, int position, int seed, double separation);
  
  //remove the first hit with id==hitid from fHitIDInAChain[MAX_CHAINS_PER_EVENT][MAX_HITS_PER_CHAIN];
  //will not touch fChainBuf yet
  //return number of hit that removed
  int  RemoveAHitFromChain(int chainid, int hitid);
  
  //remove the hit at given position  from fHitIDInAChain[MAX_CHAINS_PER_EVENT][MAX_HITS_PER_CHAIN];
  //will not touch fChainBuf yet
  //return number of hit that removed
  int  RemoveAHitFromChain_At(int chainid, int position);
  
  //sort by ID increasing order, for the same ID, sort TDC in decreasing order. 
  void QuickSort_IDTDC(int *arr, int left, int right);

  
  //print the information of the given chain
  void PrintHitPool(const char *keywords="");

  //print the information of the given chain
  void PrintAChain(int *buf, int size, const char *keywords="");
  //print the chain buffer,buf only store the hit-id
  void PrintAChain(int chainid, const char *keywords);
   
  //Sort array fHitIDInAChain[][], by S increaseing order
  void BubbleSort_S(int *arr, int size);
  void SelectSort_S(int *arr, int size);
  void InsertSort_S(int *arr, int size);
  void QuickSort_S(int *arr, int left, int right);
  //Shell Sort using gap_sequence of size/2, size/4 size/8;
  void ShellSort2_S(int *arr, int size);
  //Shell Sort using gap_sequence of 13,9,5,2,1
  void ShellSort_Seq_S(int *arr, int size);
  
  //after sorting by S, sort fHitIDInAChain[][] by Phi increaseing order
  //only sort these hits with the same TDC
  void  InsertSort_Phi(int *arr, int size);

  //sort fHitIDInAChain[][], by S increaseing order, if S equal, by phi increasing order
  void QuickSort_SPhi(int *arr, int left, int right);

  //For froward tracks, sorting by either S then Phi will work.
  //For curve back tracks, sorting by S then phi will not work.
  //Here is my solution:  
  //1) spilt the whole chain into two part: forward part + backward part
  //2) sort both part by S then phi. 
  //   Forward part: S increasing, if S equal phi increasing;
  //   Backwad part: S decreasing, if S equal phi increasing
  //3) Finally merge these 2 part together 
  void SortAChain(int chainid);

  //sort the chain by phi angle, then check s
  void BenchmarkSort(int chainid);


public:
  int       fHitNum;                      //Number of Hits in the pool
  HitStruct fHitPool[MAX_HITS_PER_EVENT]; //Keep all hits in one event


  int         fChainNum_Stored;
  //this is the buffer to store the chains, only keep pointers
  ChainStruct fChainBuf[MAX_CHAINS_PER_EVENT];   //Keep all chains


private:
  //These line is used to indicate how to search chains
  //int    anchor_hit, seed_hit, next_hit, seed_index;
  
  //to store which seed add this hit into the chain
  //this buffer is syncronized with fHitIDInAChain[][]
  //should only be operated by AddAHitToChain(int seed, int chainid, int hitid)
  int    fParentSeed[MAX_HITS_PER_CHAIN];
  double fDist2Seed[MAX_HITS_PER_CHAIN];

  //this is another buffer to store the chains, only keep HitIndex
  //It is not as convenience as fChainBuf because user have to put these id
  //back to fHitPool to extract xyz info
  int    fChainNum;
  int    fHitIDInAChain[MAX_CHAINS_PER_EVENT][MAX_HITS_PER_CHAIN];
  int    fHitNumInAChain[MAX_CHAINS_PER_EVENT];  //keep number of hits on each chain
  
  double Max_Link_Sep;
  double Max_Ang;
  double Min_Ang;
  double Ang_Sep;

};

#endif 
