//Modify by Jixie: 
//originally from Carlos Ayerbe Gayoso and BoNuS6
//Change this code to a class, add sorting algorithm
//The whole class is in unit of cm and rad
////////////////////////////////////////////////////////////////////////////////////
//How the CF work?
//parameter to search hits
//double Ini_Sep;               //the distance for the initial seed, no angle is required
//double Max_Sep, Max_Sep_Ang;  //maximum allowed distance but require smaller angle 
//double Min_Sep, Min_Sep_Ang;  //maximum allowed angle but require smaller distance
//default values: 
// Ini_Sep=1.0cm, Max_Sep=1.1cm; Max_Sep_Ang=23.3deg; Min_Sep=0.4; Min_Sep_Ang=30.0deg
//1) fill all hits into the hitpool
//2) search chains:  
//  A) add the first available hit into private  chain_buffer. using it as the 1st seed, 
//     search hits within distance of "Ini_Sep" (no angle is required). Add all found hits
//     into the chain_buffer and marked as used.  
//  B) pick to next available hit in the private chain_buffer as current seed, together with
//     its parent-seed, search hits satisfied these conditions:
//     (distance > Min_Sep && angle < Max_Sep_Ang) || (distance <= Min_Sep && angle < Min_Sep_Ang) 
//     where angle is the angle between vector1(parent-seed to seed) and vector2 (seed to hit).
//     Add all found hits into the chain_buffer and marked as used. 
//  C) repeat B) till all hits in the chain_buffer are used as seeds. 
//  D) determine whether or not to store this chain into public chain buffer "fChainBuf". Do 
//     not store if any of this is true: 
    //  a) number of hits < 5, or b) Smin > kRTPC_R_GEM1-2cm, or 
    //  c) Smax < kRTPC_R_Cathode+2cm, or d) Smax-Smin<2cm
//  E) if there are still unused hits in the pool, repeat A) B) C) and D) above.
////////////////////////////////////////////////////////////////////////////////////

#include <vector> 
using namespace std;

#ifndef _ChainFinder_H_
#define _ChainFinder_H_ 1

//If necessary, let MAX_HITS_PER_CHAIN be larger than MAX_HITS_PER_TRACK during chain 
//search such that it will loop over all hits belong to this chain. 
//However, store only MAX_HITS_PER_TRACK of hits into the final chain buffer (fChainBuf).     
#define MAX_HITS_PER_EVENT  5000   
#define MAX_CHAINS_PER_EVENT 100    
#define MAX_HITS_PER_TRACK   200             
#define MAX_HITS_PER_CHAIN   200       
#define Min_HITS_PER_CHAIN   5   


/* The status bits for hits in the hitlists */
#define HUNTCHD 0  /* - untouched - no status set yet */
#define HISUSED 1  /* - (was 1) used */
#define HREMOVD 2  /* - (was 2)removed for high residual to helix */
#define HDISEAR 4  /* - t<TPC_TMIN */
#define HDISLAT 8  /* - t>TPC_TMAX */
#define HEARLST 0x10  /* - this hit is has earliest time for this pad on this chain */
#define HABSORB 0x20  /* - hit absorbed in routine weightData */
#define HSMALLQ 0x40  /* - (was -3) charge < THR_Q_LINK */
#define HITTEMP 0x80  /* for routine-specific status marks. */
#define FAKE_HIT 0x100 /* any type of artificially-generated hit */
#define PROJECTED_HIT 0x200 /* indicates a hit generated by projecting fitted track */
#define SWUMHIT 0x400 /* indicates a hit generated by swimming the track */
#define HBADPAD 0x800 /* hit is on a pad marked as bad */
#define HITUNAV (HISUSED|HDISEAR|HDISLAT|HABSORB|HSMALLQ|FAKE_HIT|HBADPAD) /* reasons to NOT use a hit in the chain-linker */

      
//By Jixie:  I add ChainInfo to tell ChainIndex cc and HitIndex jj
//ChainInfo  = ccccjjjj,  where cc is ChainIndex and jj is HitIndex 
//ThrownTID  = ccccjjjj,  where cc is TrackIndex and jj is HitIndex 
typedef struct {
  int ID;
  int TDC;
  int ADC;
  double X;
  double Y;
  double Z;
  int Status;
  //the following is added by Jixie in order to do sorting
  double S;       // distance to beam line
  double Phi;     //from -pi to pi
  int ThrownTID;  //To tell which track it was originally from
  int ChainInfo;  //to tell which chain this hit belongs to
} HitStruct;


typedef struct {
  int ID;     //Chain ID
  int HitNum; //Number of hits in this chain
  HitStruct* Hits[MAX_HITS_PER_CHAIN];
} ChainStruct;


class ChainFinder {
public:
  ChainFinder();
  virtual ~ChainFinder();
  
  void Reset();
  //provide x,x,z in mm
  void PrepareHitPool_mm(int *id, int *tdc, int *adc, double *x_mm, double *y_mm, 
                         double *z_mm, int n, int *throwntid=0, int append=0);
  //provide x,x,z in cm
  void PrepareHitPool(int *id, int *tdc, int *adc, double *x, double *y,
                      double *z, int n, int *throwntid=0, int append=0);
                      
  //Added By Carlos, using vector instead of array, provide x,x,z in cm
  void PrepareHitPool(vector<int> *id, vector<int> *tdc, vector<int> *adc, 
		      vector<double> *x, vector<double> *y,  vector<double> *z, 
		      int n, vector<int> *throwntid=0,  int append=0);
  
  int  SearchHitsForASeed(int seed, int seed_pre); 
  void SearchChains(int do_sort=1);  
  void StoreAChain(int chainid);

  //incert a hit into hitpool at position==hitid
  void InsertAHitToPool(int hitid, int id, int tdc, int adc, double x, double y, double z, 
                        int ThrownTID=-1, int ChainInfo=-1);
  //return number of hit that removed
  int  RemoveAHitFromPool(int hitid);
  //return number of hit that removed
  int  RemoveBadHitsFromPool();
  //the real data in bonus6 it in channel ID increasing order, for the same ID,
  //TDC in decreasing order
  //sort hitpool to match this order
  void SortHitPoolByIDTDC();

  void SetParameters(double max_sep, double max_sep_ang, double min_sep, double min_sep_ang,
                     double ini_sep=1.0);

  void DrawPool();
  void DrawChain();

private:  
  
  //add a hit to end of fHitIDInAChain[MAX_CHAINS_PER_EVENT][MAX_HITS_PER_CHAIN];
  //will not touch fChainBuf yet
  //if the chain is full return 0, otherwise 1
  int  AddAHitToChain(int seed, int chainid, int hitid, double separation);

  //incert a hit to given position of fHitIDInAChain[MAX_CHAINS_PER_EVENT][MAX_HITS_PER_CHAIN];
  //will not touch fChainBuf yet
  void InsertAHitToChain(int chainid, int hitid, int position, int seed, double separation);
  
  //remove the first hit with id==hitid from fHitIDInAChain[MAX_CHAINS_PER_EVENT][MAX_HITS_PER_CHAIN];
  //will not touch fChainBuf yet
  //return number of hit that removed
  int  RemoveAHitFromChain(int chainid, int hitid);
  
  //remove the hit at given position  from fHitIDInAChain[MAX_CHAINS_PER_EVENT][MAX_HITS_PER_CHAIN];
  //will not touch fChainBuf yet
  //return number of hit that removed
  int  RemoveAHitFromChain_At(int chainid, int position);
  
  //sort by ID increasing order, for the same ID, sort TDC in decreasing order. 
  void QuickSort_IDTDC(int *arr, int left, int right);

  
  //print the information of the given chain
  void PrintHitPool(const char *keywords="");

  //print the information of the given chain
  void PrintAChain(int *buf, int size, const char *keywords="");
  //print the chain buffer,buf only store the hit-id
  void PrintAChain(int chainid, const char *keywords);
   
  //Sort array fHitIDInAChain[][], by S increaseing order
  void BubbleSort_S(int *arr, int size);
  void SelectSort_S(int *arr, int size);
  void InsertSort_S(int *arr, int size);
  void QuickSort_S(int *arr, int left, int right);
  //Shell Sort using gap_sequence of size/2, size/4 size/8;
  void ShellSort2_S(int *arr, int size);
  //Shell Sort using gap_sequence of 13,9,5,2,1
  void ShellSort_Seq_S(int *arr, int size);
  
  //after sorting by S, sort fHitIDInAChain[][] by Phi increaseing order
  //only sort these hits with the same TDC
  void  InsertSort_Phi(int *arr, int size);

  //sort fHitIDInAChain[][], by S increaseing order, if S equal, by phi increasing order
  void QuickSort_SPhi(int *arr, int left, int right);

  //For froward tracks, sorting by either S then Phi will work.
  //For curve back tracks, sorting by S then phi will not work.
  //Here is my solution:  
  //1) spilt the whole chain into two part: forward part + backward part
  //2) sort both part by S then phi. 
  //   Forward part: S increasing, if S equal phi increasing;
  //   Backwad part: S decreasing, if S equal phi increasing
  //3) Finally merge these 2 part together 
  void SortAChain(int chainid);

  //sort the chain by phi angle, then check s
  void BenchmarkSort(int chainid);


public:
  int       fHitNum;                      //Number of Hits in the pool
  HitStruct fHitPool[MAX_HITS_PER_EVENT]; //Keep all hits in one event


  //this is the public buffer to store the chains, only keep pointers
  int         fChainNum_Stored;
  ChainStruct fChainBuf[MAX_CHAINS_PER_EVENT];   //Keep all chains


private:
  //parameter to search hits
  double Ini_Sep;               //the distance for the initial seed, no angle is required
  double Max_Sep, Max_Sep_Ang;  //maximum allowed distance but require smaller angle 
  double Min_Sep, Min_Sep_Ang;  //maximum allowed angle but require smaller distance

  //to store which seed add this hit into the chain
  //this buffer is syncronized with fHitIDInAChain[][]
  //should only be operated by AddAHitToChain(int seed, int chainid, int hitid)
  int    fParentSeed[MAX_HITS_PER_CHAIN];
  double fDist2Seed[MAX_HITS_PER_CHAIN];

  //this is the private buffer to store the chains, only keep HitIndex
  //user have to put these id back to fHitPool to extract xyz info
  //note that not every chain is stored into the public buffer
  int    fChainNum;
  int    fHitIDInAChain[MAX_CHAINS_PER_EVENT][MAX_HITS_PER_CHAIN];
  int    fHitNumInAChain[MAX_CHAINS_PER_EVENT];  //keep number of hits on each chain
};

#endif 
