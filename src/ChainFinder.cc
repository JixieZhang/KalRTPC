
/* The status bits for hits in the hitlists */
#define HUNTCHD 0  /* - untouched - no status set yet */
#define HISUSED 1  /* - (was 1) used */
#define HREMOVD 2  /* - (was 2)removed for high residual to helix */
#define HDISEAR 4  /* - t<TPC_TMIN */
#define HDISLAT 8  /* - t>TPC_TMAX */
#define HEARLST 0x10  /* - this hit is has earliest time for this pad on this chain */
#define HABSORB 0x20  /* - hit absorbed in routine weightData */
#define HSMALLQ 0x40  /* - (was -3) charge < THR_Q_LINK */
#define HITTEMP 0x80  /* for routine-specific status marks. */
#define FAKE_HIT 0x100 /* any type of artificially-generated hit */
#define PROJECTED_HIT 0x200 /* indicates a hit generated by projecting fitted track */
#define SWUMHIT 0x400 /* indicates a hit generated by swimming the track */
#define HBADPAD 0x800 /* hit is on a pad marked as bad */
#define HITUNAV (HISUSED|HDISEAR|HDISLAT|HABSORB|HSMALLQ|FAKE_HIT|HBADPAD) /* reasons to NOT use a hit in the chain-linker */

//Modify by Jixie: 
//Change this code into a class
#include <iostream>
#include <math.h>
#include <stdio.h>
#include "TVector3.h"

#include "ChainFinder.hh"


/*
//this is an example how to use this class 
void EXample()
{
  ChainFinder pTF;  
  pTF->SetParameters(v1,v2,v3,v4);
  for(int ii;ii<nevents;ii++) {
    pTF.Reset();
    pTF.PrepareHitPool(vvv);
    pTF.RemoveBadHits();
    pTF.SearchChains();
    //call KF
    for(int i=0;i<fChainNum;i++) DoKalmanFilter();  
  }
}
*/

using namespace std;

static const double rad2deg = 180./(4.*atan(1.));


ChainFinder::ChainFinder() 
{
  fHitNum = 0;
  fChainNum = 0;
  for(int i=0;i<MAX_CHAINS_PER_EVENT;i++) {
    fHitNumInAChain[i] = 0;  
    for(int j=0;j<MAX_HITS_PER_CHAIN;j++) fHitIDInAChain[i][j]=0;
  }
}

ChainFinder::~ChainFinder() 
{
    //
}

void ChainFinder::Reset() 
{
  fHitNum = 0;
  for(int i=0;i<fChainNum;i++) {
    for(int j=0;j<fHitNumInAChain[i];j++) fHitIDInAChain[i][j]=0;
    fHitNumInAChain[i] = 0;  
  }
  fChainNum = 0;
}


//provide x,x,z in cm
void ChainFinder::PrepareHitPool(double *x, double *y, double *z, int n, int append)
{
  TVector3 pV3;
  if(append==0) fHitNum=0; 
  for(int i=0;i<n;i++) {
    if(fHitNum < MAX_HITS_PER_EVENT) {
      fHitPool[fHitNum].X=x[i];
      fHitPool[fHitNum].Y=y[i];
      fHitPool[fHitNum].Z=z[i];
      fHitPool[fHitNum].Status=HUNTCHD;
      //The following is added by Jixie for sorting
      pV3.SetXYZ(x[i],y[i],z[i]);
      fHitPool[fHitNum].S=pV3.Perp();
      fHitPool[fHitNum].Z=pV3.Phi();
      fHitNum++;
    } else {
      cout<<"MAX_HITS_PER_EVENT("<<MAX_HITS_PER_EVENT<<") is too small, tracks are potentially lost!\n";
    }
  }
}

void ChainFinder::InsertAHit(int hitid, double x, double y, double z, double ThrownTID)
{
  for(int i=fHitNum;i>hitid;i--) {
      fHitPool[i].X=fHitPool[i-1].X;
      fHitPool[i].Y=fHitPool[i-1].Y;
      fHitPool[i].Z=fHitPool[i-1].Z;
      fHitPool[i].Status=fHitPool[i-1].Status;
      fHitPool[i].S=fHitPool[i-1].S;
      fHitPool[i].Phi=fHitPool[i-1].Phi;
      fHitPool[i].ThrownTID=fHitPool[i-1].ThrownTID;
  }
  
  fHitPool[hitid].X=x;
  fHitPool[hitid].Y=y;
  fHitPool[hitid].Z=z;
  fHitPool[hitid].Status=HUNTCHD;
  fHitPool[hitid].S=sqrt(x*x+y*y);
  fHitPool[hitid].Z=atan2(y,x);
  fHitPool[hitid].ThrownTID=ThrownTID;
  fHitNum += 1;
}


void ChainFinder::RemoveAHit(int hitid)
{
  for(int i=hitid;i<fHitNum;i++) {
      fHitPool[i].X=fHitPool[i+1].X;
      fHitPool[i].Y=fHitPool[i+1].Y;
      fHitPool[i].Z=fHitPool[i+1].Z;
      fHitPool[i].Status=fHitPool[i+1].Status;
      fHitPool[i].S=fHitPool[i+1].S;
      fHitPool[i].Phi=fHitPool[i+1].Phi;
      fHitPool[i].ThrownTID=fHitPool[i+1].ThrownTID;
  }
  fHitNum -= 1;
}

//This is for changing status for hits before search
//For example, if we want to remove bad hits or 
void ChainFinder::RemoveBadHits()
{
  //
}


void ChainFinder::SetParameters(double space, double max_ang, double min_ang, double ang_sep)
{
  // USER SHOULD PROVIDE THESE VARIABLES
  Max_Link_Sep = space;
  Max_Ang      = max_ang;
  Min_Ang      = min_ang;
  Ang_Sep      = ang_sep;
}
  
void ChainFinder::AddHitToChain(int hitid)
{
  if (fHitNumInAChain[fChainNum] >= MAX_HITS_PER_CHAIN) {        
    printf("Too many hits for the chain list. Skip...\n"); 
  }
    
  //THE HIT INDEX WHICH ACOMPLISH THE CONDITION, IS STORED-->
  fHitIDInAChain[fChainNum][fHitNumInAChain[fChainNum]] = hitid;
  
  /* mark it as used */
  fHitPool[hitid].Status |= HISUSED; //this kind of assignment is for 'historical' reasons
  fHitNumInAChain[fChainNum]++;      //ADD HIT TO THE CHAIN, INCREASE INDEX
  
}


//fid hits for a given seed(pivot)
//nhits: number of hits inside the event
void ChainFinder::SearchHitsForASeed(int seed, int seed_pre) // HitStruct* fHitPool, int nhits)
{
  //declare the 3 vector here to avoid construction and deconstruction frequently
  TVector3 pV3_seed_pre(fHitPool[seed_pre].X, fHitPool[seed_pre].Y, fHitPool[seed_pre].Z);
  TVector3 pV3_seed(fHitPool[seed].X, fHitPool[seed].Y, fHitPool[seed].Z);
  TVector3 pV3_pre(0,0,0);
  TVector3 pV3(0,0,0);
  TVector3 pV3Diff, pV3Diff_pre;
     
  //current number of hits in this chain
  pV3Diff_pre = pV3_seed-pV3_seed_pre;
  
  //NOTE: start from 0, 
  for(int i = 0; i<fHitNum; i++) {
    if(fHitPool[i].Status & HITUNAV) continue;
    if(seed == i) continue;
    
    pV3.SetXYZ(fHitPool[i].X, fHitPool[i].Y, fHitPool[i].Z);
    //for some reason, if the hit is not valid, it could be set to (0,0,0) or (9999.,9999.;9999.)
    if (pV3.Perp()<2.0 || pV3.Perp()>8.0) continue;  
  
    if(i>0) pV3_pre.SetXYZ(fHitPool[i-1].X, fHitPool[i-1].Y, fHitPool[i-1].Z);
    
    // removes the same hits (perhaps redundant)
    //if (!(pV3-pV3_pre).Mag() == 0)  never use ==0 to judge a floating number
    if ( (pV3-pV3_pre).Mag() <= 1.0E-5 ) {
      fHitPool[i].Status |= HISUSED;
      continue;
    } 
    
    pV3Diff = pV3 - pV3_seed;
    
    //check the distance
    double separation = pV3Diff.Mag();
    if( separation > Max_Link_Sep ) continue; 
    
    //for the first seed of a chain, do not check angle 
    if(seed == seed_pre) {
      AddHitToChain(i);
      continue;
    }
    
    //check the angle between pV3_diff and pV3_diff_pre
    double acceptance = pV3Diff.Angle(pV3Diff_pre) *rad2deg;
    
    //not very sure we need this line    
    if(acceptance>90.) acceptance = 180. - acceptance;
        
    if ( (separation <= Ang_Sep && acceptance < Max_Ang-15) || 
         (separation >  Ang_Sep && acceptance < Min_Ang-10) ) {					
      AddHitToChain(i);
    } 
  }
}


void ChainFinder::SearchChains() //HitStruct *fHitPool, int nhits)
{
  //reset fChainNum = 0;  
  fChainNum = 0;
  fHitNumInAChain[fChainNum] = 0;
  
  //loop over the seed pool, currently every point could be the seed
  int seed = 0, seed_pre = 0;
  for (int i=0; i < fHitNum; i++) {  //ancor_hit
    //do nothing if this hit has been marked as used or unavailable
    if ( fHitPool[i].Status & HITUNAV )  continue;
      
    //add the initial seed into this chain  
    if(fHitNumInAChain[fChainNum] == 0) {  
      seed = i;
      AddHitToChain(seed);
      //fHitNumInAChain[fChainNum] will be added by 1 inside 
    }
        
    //SEARCH ALGORITHM----->
    //search a chain: looping over all founded seeds
    //Note that fHitNumInAChain[fChainNum] will self increasing if hits added into the chain
	  for (int seed_idx=0; seed_idx<fHitNumInAChain[fChainNum]; seed_idx++) {
    
      //Fix me: currently the chain result are not sorted yet
      //need to do this before passing to Kalman Filter
      seed = fHitIDInAChain[fChainNum][seed_idx]; 
      if (seed_idx==0) seed_pre=seed;
      SearchHitsForASeed(seed, seed_pre);
      seed_pre = seed;
    }
    
    //judge if this chain is valid or not, do not store it if less than 6 hits
    if( fHitNumInAChain[fChainNum] >= 6) {
        StoreAChain();
    } else {
      //release this initial seed back to the pool
      //I think we should not do it, or we should release all hits inside this invalid chain
      //need to debug this
      fHitPool[seed].Status &= ~HISUSED;
    }
  
  }// for (int i = 0; i < nhits; i++) 

}
  


void ChainFinder::StoreAChain()
{
  printf("\t Store chain #%d: %d hits \n", fChainNum,fHitNumInAChain[fChainNum]);
  
  
  for (int jj=0; jj<fHitNumInAChain[fChainNum]; jj++)
    {
      printf(" %d", fHitIDInAChain[fChainNum][jj]);
      //Fill the pointer of found chain
      fChainBuf[fChainNum].Hits[jj] = &(fHitPool[fHitIDInAChain[fChainNum][jj]]);
    }

  fChainBuf[fChainNum].HitNum = fHitNumInAChain[fChainNum];//number of hits in the chain
  fChainBuf[fChainNum].ID = fChainNum;  //this chain index 
  
  printf("\n\n");

  fChainNum++; //NEW CHAIN, INCREASE THE INDEX
}




